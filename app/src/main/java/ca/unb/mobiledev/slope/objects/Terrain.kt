package ca.unb.mobiledev.slope.objects

import android.content.Context
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.util.Log
import ca.unb.mobiledev.slope.Collision
import ca.unb.mobiledev.slope.ObjectView
import ca.unb.mobiledev.slope.Vec2
import kotlin.random.Random

import ca.unb.mobiledev.slope.R.drawable.coin as texture

import ca.unb.mobiledev.slope.noise.SimplexNoise_Octave as Noise

class Terrain(context: Context?, displayWidth: Int, displayHeight: Int, objId: Int)
    :ObjectView(context,displayWidth,displayHeight,objId) {

    val SEGMENT_WIDTH = 250f
    val NOISE_STEP = 1f
    val HEIGHT_SPREAD = 100f //how much

    override val defaultBitmap = texture

    var extents = Vec2(32f,32f)
    //var collider = Collision.BoxCollider(position,extents)

    val y= Random.nextInt()
    //0 = random seed
    val noise = Noise(0)//Noise(Random(System.currentTimeMillis()).nextInt()) //Random isnt very random, so give it
    //a semi random seed


    //private var samples = mutableListOf<Float>()
    private var segments = mutableListOf<Segment>()

    private var verts_mutable = mutableListOf<Float>()
    private lateinit var verts:FloatArray

    override fun start(){

        //setBitmap()
        //val variation = noise.noise(1.0,0.0).toFloat()
        //Log.i("test",variation.toString())
        //position += Vec2(0f,100+200*variation)
        //collider.position = position-Vec2(0f,100f)



        for(i in 0..5){
            val height_1 = noise.noise(i*NOISE_STEP.toDouble(),0.0).toFloat()
            val height_2 = noise.noise((i+1)*NOISE_STEP.toDouble(),0.0).toFloat()
            segments.add(Segment(
                Vec2(i*SEGMENT_WIDTH,height_1*HEIGHT_SPREAD),
                Vec2((i+1)*SEGMENT_WIDTH,height_2*HEIGHT_SPREAD))
            )

        }
        segments.forEach {
            verts_mutable.addAll(it.getVertices())
        }
        verts = displaceVerts(verts_mutable,Vec2(0f,600f)).toFloatArray()

        //val segment = Segment(Vec2(0f,250f),Vec2(300f,100f))
        //verts = displaceVerts(segment.getVertices(),Vec2(500f,600f)).toFloatArray()

    }

    override fun update(deltaT : Float, objMap:Map<String,ObjectView>){

    }

    /*fun vecsToTri(a:Vec2,b:Vec2,c:Vec2):FloatArray{
        return floatArrayOf(a.x,a.y,b.x,b.y,c.x,c.y)
    }*/


    private fun displaceVerts(ar:MutableList<Float>,d:Vec2):MutableList<Float>{
        val x = mutableListOf<Float>()
        var i = 0
        ar.forEach {
            if(i.mod(2)==0){
                x.add(it + d.x)
            }
            else{
                x.add(it + d.y)
            }
            i += 1
        }
        Log.i("Terrain",x.toString())
        return x
    }


    //we don't want to draw a texture since terrain is autogenerated
    @Synchronized
    override fun onDraw(canvas: Canvas) {
        //val verts = floatArrayOf(200f,100f,250f, 300f, 400f, 150f)

        //needs to match the length of verts we ask to draw
        /*val verticesColors = intArrayOf(
            Color.RED, Color.RED, Color.RED,
            Color.RED, Color.RED, Color.RED
        )*/

        //triangle_strip lets us reuse some verts
        canvas.drawVertices(Canvas.VertexMode.TRIANGLES,//TRIANGLE_STRIP,//TRIANGLES,
            verts.size, verts,0,
            null,0,
        null,0,//verticesColors,0,
        null,0, 0,
            Paint()
        )

    }

    class Segment(val l: Vec2,val r: Vec2){
        private val m = getSlope()
        private val b = getOffset()
        //get m from y=mx+b
        private fun getSlope():Float{
            return (r.y-l.y)/(r.x-l.x) //negative?
        }

        private fun getOffset():Float{
            return l.y
        }

        fun checkPlayerCollision(playerPos:Vec2):Vec2{
            val slopeY = m*playerPos.x + b
            if(playerPos.y > slopeY){
                return Vec2(playerPos.x,slopeY)
            }
            else{
                return playerPos
            }
        }

        fun getVertices(): MutableList<Float> {
            return mutableListOf<Float>(
                //tri 1
                l.x,-l.y,
                r.x,-r.y,
                l.x,1000f,

                //tri 2
                r.x,-r.y,
                r.x,1000f,
                l.x,1000f
            )
        }
        fun getVerticesFinal(): FloatArray {
            return floatArrayOf(
                //tri 1
                l.x,-l.y,
                r.x,-r.y,
                l.x,1000f,

                //tri 2
                r.x,-r.y,
                r.x,1000f,
                l.x,1000f
            )
        }
    }

}