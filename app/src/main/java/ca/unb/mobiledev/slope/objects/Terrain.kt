package ca.unb.mobiledev.slope.objects

import android.content.Context
import android.graphics.*
import ca.unb.mobiledev.slope.ObjectView
import ca.unb.mobiledev.slope.R
import ca.unb.mobiledev.slope.Vec2
import kotlin.math.atan
import kotlin.random.Random
import ca.unb.mobiledev.slope.R.drawable.coin as texture
import ca.unb.mobiledev.slope.noise.SimplexNoise_Octave as Noise

// Terrain
class Terrain(context: Context?, val displayWidth: Int, val displayHeight: Int, objId: Int,
              val obstacles: MutableList<Obstacle>, val bg:MutableList<Background>)
    :ObjectView(context,displayWidth,displayHeight,objId) {

    private val SEGMENT_WIDTH = 200f //250f
    private val NOISE_STEP = 0.2f //1f
    private val HEIGHT_SPREAD = 150f //how much //100f

    override val defaultBitmap = texture


    val y = Random.nextInt()

    //0 = random seed
    val noise = Noise(0)

    private var segments = mutableListOf<Segment>()

    private var verts_mutable = mutableListOf<Float>()
    private lateinit var verts:FloatArray

    var offset = Vec2(0f,-600f)

    private var lastSegment = 0

    var vertExtraOffset = Vec2(0f,0f)

    val triPaint = Paint().apply{
        val bitmap = BitmapFactory.decodeResource(
            resources, R.drawable.ground
        )
        val shader = BitmapShader(
            bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)
        this.shader = shader
    }

    // Startup function. Called at the start of the game to generate initial level layout
    override fun start(objMap:Map<String,ObjectView>){
        generateNewSegments(12,0f)
        for(ob in obstacles){
            cycleObstacle(false)
        }
    }

    // Unused default update method
    override fun update(deltaT : Float, objMap:Map<String,ObjectView>){

    }

    // Move obstacle from one position to another when it moves off screen
    fun cycleObstacle(checkOnScreen:Boolean=true){
        val sortedObstacles = obstacles.sortedBy { it.position.x }

        if((!sortedObstacles[0].isOnScreen() && checkOnScreen) || !checkOnScreen){
            val rand = Random(System.currentTimeMillis()).nextFloat()*3
            val x = (lastSegment.toFloat()+rand-3f)*SEGMENT_WIDTH

            sortedObstacles[0].position = playerCollide(Vec2(x,0f))
            sortedObstacles[0].collider.position = sortedObstacles[0].position
        }
    }

    // Unused method to cycle a moving background around
    fun cycleBackground(){
        val sortedObstacles = bg.sortedBy { it.position.x }

        if(sortedObstacles[0].isOnScreen()){
            val rand = Random(System.currentTimeMillis()).nextFloat()*3
            val x = (lastSegment.toFloat()+rand-3f)*SEGMENT_WIDTH

            sortedObstacles[0].position = playerCollide(Vec2(x,0f))
            sortedObstacles[0].position.y += sortedObstacles[0].yOffset
        }
    }

    private val overallSlope = -0.25f

    // Find gradient for terrain segment
    fun gradient(seg:Int):Float{
        val x = seg*SEGMENT_WIDTH
        return overallSlope*x
    }

    // Generate new segments when needed
    fun generateNewSegments(numSegments:Int=2, yOffset: Float) {
//        segments = mutableListOf<Segment>()
        for(i in 0..numSegments){
            val height_1 = noise.noise((i+lastSegment)*NOISE_STEP.toDouble(),0.0).toFloat()
            val height_2 = noise.noise((i+1+lastSegment)*NOISE_STEP.toDouble(),0.0).toFloat()
            segments.add(Segment(
                Vec2((i+lastSegment)*SEGMENT_WIDTH + offset.x,(height_1*HEIGHT_SPREAD) + gradient(lastSegment+i) + offset.y),
                Vec2((i+1+lastSegment)*SEGMENT_WIDTH + offset.x,(height_2*HEIGHT_SPREAD)+ gradient(lastSegment+1+i) + offset.y))
            )
        }
        lastSegment += numSegments+1
        segments.forEach {
            verts_mutable.addAll(it.getVertices(yOffset))
        }
    }

    // Unused method to displace segments if needed
    fun displaceSegs(d:Vec2){
        segments.forEach {
            it.updateCoords(d)
        }
    }

    // Displace vertexes to the position it is supposed to be at
    private fun displaceVerts(ar:MutableList<Float>,d:Vec2):MutableList<Float>{
        val x = mutableListOf<Float>()
        var i = 0
        ar.forEach {
            if(i.mod(2)==0){
                x.add(it + d.x)
            }
            else{
                x.add(it + d.y)
            }
            i += 1
        }
        return x
    }

    //we don't want to draw a texture since terrain is autogenerated
    @Synchronized
    override fun onDraw(canvas: Canvas) {
        canvas.drawVertices(Canvas.VertexMode.TRIANGLES,
            verts.size, verts,0,
            verts,0,
        null,0,
        null,0, 0,
            triPaint//Paint()
        )
    }

    // Get angle of ground segment under players feet
    fun getPlayerAngle(playerPos:Vec2):Float{
        val segment = getSegmentByPlayerPos(playerPos)
        if(segment != null){
            return Math.toDegrees(segment.getAngle().toDouble()).toFloat()
        }
        return 0f;
    }

    // Collide with player to ensure we don't fall through the map
    fun playerCollide(playerPos:Vec2):Vec2{
        val segment = getSegmentByPlayerPos(playerPos)
        if(segment != null){
            return segment.getSurfacePos(playerPos.x)
        }
        return Vec2(-1f,-1f)
    }

    // Check collision and return boolean if collision occurs
    fun checkPlayerCollide(playerPos:Vec2):Boolean{
        val segment = getSegmentByPlayerPos(playerPos)
        if(segment != null) {
            return segment.checkPlayerCollision(playerPos)
        }
        return false
    }

    // Get the id of current segment player is over/on
    fun getSegmentNum(playerPos: Vec2):Int{
        val segmentNum = (playerPos.x/SEGMENT_WIDTH).toInt()
        if(segmentNum < segments.size) return segmentNum
        return -1
    }

    // Get amount of segments currently generated
    fun getNumSegments():Int{
        return lastSegment
    }

    // Get the current segment player is over/on
    private fun getSegmentByPlayerPos(playerPos:Vec2):Segment?{
        val segmentNum = (playerPos.x/SEGMENT_WIDTH).toInt()
        if(segmentNum < segments.size){
            return segments[segmentNum]
        }
        return null
    }

    // Render the terrain to the camera
    override fun render(camera: Vec2) {
        //displace the vertices' screenposition
        verts = displaceVerts(verts_mutable,-camera).toFloatArray()
        this@Terrain.postInvalidate()

    }

    // Class for the individual terrain segment
    class Segment(val lIn: Vec2, val rIn: Vec2){
        var l = lIn
        var r = rIn

        // Update the segment coordinates using a Vector 2
        fun updateCoords(offset:Vec2){
            l = lIn+offset
            r = rIn+offset
        }
        private val m = getSlope()
        private val b = -l.y //getOffset()

        private val horizontalOffset = l.x
        //get m from y=mx+b

        // Get the slope of segment
        private fun getSlope():Float{
            return -(r.y-l.y)/(r.x-l.x) //negative? >>
        }

        // Get angle of segment
        fun getAngle():Float{
            //atan = inverse tan
            return atan(m)
        }

        // Get surface position of segment
        fun getSurfacePos(x:Float):Vec2{
            val slopeY = (x-horizontalOffset)*m +b//x/m + b
            return Vec2(x,slopeY) //return playerPos
        }

        // Check if player is colliding with segment
        fun checkPlayerCollision(playerPos:Vec2):Boolean{
            return playerPos.y > getSurfacePos(playerPos.x).y
        }

        // Get the vertices that make up the segment
        fun getVertices(yOffset:Float): MutableList<Float> {
            return mutableListOf<Float>(
                //tri 1
                l.x,-l.y,
                r.x,-r.y,
                l.x,1500f+yOffset,

                //tri 2
                r.x,-r.y,
                r.x,1500f+yOffset,
                l.x,1500f+yOffset
            )
        }

        // Get the vertices that make up segment without taking into account offsets
        fun getVerticesFinal(): FloatArray {
            return floatArrayOf(
                //tri 1
                l.x,-l.y,
                r.x,-r.y,
                l.x,1000f,

                //tri 2
                r.x,-r.y,
                r.x,1000f,
                l.x,1000f
            )
        }
    }
}